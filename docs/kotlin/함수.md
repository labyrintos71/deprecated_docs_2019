---
layout: default
title: 함수
parent: Kotlin
nav_order: 7
---
#  함수
## 기본 함수 형태
```kotlin
public fun makeText(): String {
    return "x = $x y = $y"
}

//코틀린에선 Unit이 void
fun printText(): Unit {
    print("x = $x y = $y")
}
```
#### Space
## 람다식
람다식이란 식별자 없이 실행가능한 함수를 의미한다.
```kotlin
//람다식은 왼쪽이든 오른쪽이든 자료형을 지정해줘야 한다.
fun a(): Int = 1

//람다식, 자료형 지정
var sum: (Int, Int) -> Int = { a: Int, b: Int -> a + b }
//람다식, 자료형 오른쪽에만 지정
var sum1 = { a: Int, b: Int -> a + b }
//람다식, 자료형 왼쪽에만 지정
var sum2: (Int, Int) -> Int = { a, b -> a + b }

//람다식, 리턴값이 없을경우 예제
val funcSayHi: (String) -> Unit = { name: String -> println("Hi $name") }

//메소드에 람다식을 인수로 받는 예제
fun main(args: Array<String>) {
    temp(1, 2, { a: Int, b: Int -> a + b })
    temp(1, 2) { a: Int, b: Int -> a + b }
    temp(1, 2, ::sum3)
    emptyrambda(3) { 7 }
    emptyrambda(3, { 7 })
    emptyrambda(3, { -> 7 })
    emptyrambdas(3) { a: Int -> a + 7 }
}

fun temp(a: Int, b: Int, c: (Int, Int) -> Int) = c(a, b)
fun sum3(a: Int, b: Int): Int {
    return a + b
}

fun emptyrambda(a: Int, c: () -> Any) = c()
fun emptyrambdas(a: Int, c: (a: Int) -> Any) = c(a)
```


  //인자 여러개 받을때
    fun varags() {
        val list = arrayOf("as", "as1", "as2", "as3")
        varargTest(*list)
    }

    fun varargTest(vararg numbers: Int) {
        numbers.map { it ->
            println(it)
        }
    }

    fun varargTest(vararg a: String) {
        for (a_ in a) {
            println(a_)
        }
    }


    //익명함수
    var funcSum = fun(a: Int, b: Int): Int { return a + b }
    /*
    람다식 안에서 return 할 수 없는 경우가 있습니다.
    처리 중간에 조건을 주고 중간에 빠져나오고 싶지만 return이 없는 람다식의 경우입니다.
    아래 예제와 같은 람다식에서 조건에 일치하는 경우 처리를 종료하고 싶은 경우를 보겠습니다.

    numbers.forEach { number ->
        if (number % 2 == 1) {
            // 여기에서 처리를 끝내고 싶은 경우
        }

        ...
    }
    이러한 경우에는 람다식이 아닌 익명 함수를 사용하는 것이 좋습니다.

    numbers.forEach(fun(number: Int) {
        if (number % 2 == 1) {
            return // 처리 종류
        }

        ...
    })
    */

    //Object
    //싱글톤 지원 기능
    //오브젝트 는 싱글통 지원을 위해 만들어짐. 저상태로 사용해도됨
    //companion 오브젝트는 클래스에서 오브젝트로 선언한 부분만 싱글톤화 됨.
    

    //use
    //use 키워드는 스트림의 close를 자동으로 해줌
    //안드로이드에서는 이게 있음openFileInput
    /*   FileInputStream("file.txt").use {
           input ->
           var data = input.read()
           println(data)
       }*/


    //확장함수
    var strs = "섹스"
    val addStr = fun String.(str: String): String {
        return this + str
    }

  /*  fun String.deleteLastStr(successor: String): String {
        return this + successor
    }*/
    // 여기서 리시버타입은 String이된다. 즉 확장하는 자기 자신의 타입인것
    //책에서 나오는 리터럴은 람다를 넘겨준 식. 즉 표현식 그 자체임
    //         여기 부분
    private fun String.deleteLastStr(): String {
        return this.substring(0,this.length-1)
    }

    private fun Any.deleteLastStrㄴ(): String {
        return this.toString().substring(0)
    }
    var s = 1
    // str = str.addStr("하기 딱 좋은 날씨로구나.")

    //확장함수 심화
    fun extendFun() {
        fun String.lastChar1(): Char = this.get(this.length - 1)

        //this 생략 가능
        fun String.lastChar2(): Char = get(length - 1)

        fun <T> Collection<T>.convertToString(
            separator: String = ",",
            prefix: String = "(",
            postfix: String = ")"
        ): String {
            var result = prefix
            this.map { it.toString()+separator }.forEach { result = result + it }
            // == this.forEach { result = result + it + separator }
            return result.deleteLastStr() + postfix
        }

        //String 제네릭
        fun Collection<String>.join(
            separator: String = ",",
            prefix: String = "(",
            postfix: String = ")"
        ): String = this.toString() + " numbers"
        //사용
        val intlist = listOf(1, 2, 3, 4)
        //intlist.join() //에러!!! Int 타입은 불가능하다
        // 사용
        val list = listOf("1", "2", "3")
        print(list.joinToString())
    }

    //확장 프로퍼티
    class extendProperty {
        //get() 구현
        val String.lastChar: Char
            get() = get(length - 1)
        //  get() { return last().toString()}

        //리스트인경우 get(), set() 구현
        var List<Any>.name: String
            get() = name
            set(value) {
                name = last().toString()
            }

        fun test() {
            "zerog".lastChar        //확장 프로퍼티 호출
            val list = listOf("a", "b", "c")
            list.name              //get()
            list.name = "d"      //set()
        }
    }